## Class 18 - Recommenders

### The General Idea

Recommendation systems aim to match users to products / items / brands / etc. that they likely have not experienced yet.

Ratings (predicted ratings) are produced by analyzing other user/item ratings (and sometimes item characteristics) to provide personalized recs to users

### General Approaches: 2 Methods

**Content-based Filtering:** Items are mapped into a feature space, and recs are dependent on *item characteristics*

Examples:
- Amazon book recommendations based on topic (e.g. programming)
- Netflix "Ask Max"
- Pandora tagging
- NYTimes.com topic tags

**Collaborative Filtering:** Only data under consideration are user-item ratings, and recommendations are dependent on *user preferences*

Examples:
- Amazon recommendations based on "Users Who Bought This Item Also Bought"
- Netflix Facebook hooks
- last.fm recommendations

### Content-based Filtering

Begins by mapping each item into a feature space.  Both users and items are represented by vectors in this space.

**Item vectors** measure the degree to which the item is described by each feature, and **user vectors** measure a user's preferences for each feature.

Ratings are generated by taking the **dot product** of the user and item vectors.

#### Difficulties with Content-based Filtering

- Must map items into a feature space (usually by hand!)
- Recommendations are limited in scope (items must be similar to each other)
- Hard to create cross-content recommendations (e.g. books/music/films -- this would require comparing elements from different feature spaces)

### Collaborative Filtering

Collaborative filtering refers to a family of methods for predicting ratings where instead of thinking about users and items in terms of a feature space, we are only interested in the existing user-item ratings themselves.

In this case, our dataset is a **ratings matrix** whose columns correspond to items, and whose rows correspond to users.

#### Main difference between content-based and collaborative filtering:

- Content-based: maps items and users into a feature space
- Collaborative: relies on previous user-item ratings

#### Collaborative filtering: user-user perspective

Taking a given user, find the K most similar users, and then recommend items to them from similar users.

### The Cold Start problem

The system cannot draw inferences because it hasn't gathered enough information yet.  

This problem arises particularly in collaborative filtering, as it relies on ratings or explicit feedback from users; without this pre-existing data, how to make recommendations?  Until users rate several items, we don't know anything about their preferences.

We can get around this by enhancing recs using "implicit feedback", which may include things like item browsing behavior, search patterns, purchase history, etc.

While explicit feedback (ratings, likes, purchases) leads to high-quality ratings, the data are sparse and cold starts are problematic.

Implicit feedback leads to less accurate ratings, but the data are much more dense.

### Jaccard Similarity

Defines similarity between two **sets** of objects.

JS(A, B) = |A intersect B| / |A union B|

...or, number of similar elements divided by the number of distinct elements.

Example:

JS({1, 2, 3}, {2, 3, 4})    = |{2, 3}| / |{1, 2, 3, 4}|
                            = 2 / 4

**NB:** Jaccard similarity ranges from 0 to 1.  

### Examples in Python

Our data:
- CSV of two columns: User ID, and Brand
- Each row represents a User "liking" a Brand

How do we define "similarity" of users?  This is required if we want to do user-based collaborative filtering.

Our algo:
1. Get list of known users in a dictionary where the key is the User ID, and the value is a list of brands that they like
2. For a given user, calculate their closeness to every user in the CSV
3. Chose the K most similar users
4. Recommend brands liked by similar users

```python

import pandas as pd
from collections import Counter
#read in brands data
user_brands = pd.read_csv('data/user_brand.csv')
# user_brands = pd.read_csv('https://raw.githubusercontent.com/justmarkham/DAT4/master/data/user_brand.csv')

#look at count of stores
user_brands.Store.value_counts()

# Series of user IDs, note the duplicates
user_ids = user_brands.ID

# groupby ID to see what each user likes!
user_brands.groupby('ID').Store.value_counts()

# turns my data frame into a dictionary (dict comprehension)
# where the key is a user ID, and the value is a
# list of stores that the user "likes"
brandsfor = {str(k): list(v) for k,v in user_brands.groupby("ID")["Store"]}

'''
EXERCISE: Complete the jaccard method below.
          It should take in a list of brands, and output the
          jaccard similarity between them

This should work with anything in the set, for example
jaccard([1,2,3], [2,3,4,5,6])  == .3333333

HINT: set1 & set2 is the intersection
      set1 | set2 is the union

'''

def jaccard(first, second):
    first = set(first)
    second = set(second)
    # the line below should be changed
    return len(first & second) / float(len(first | second))

#######################
### Our Recommender ###
#######################

'''
Our recommender will be a modified KNN collaborative algorithm.
Input: A given user's brands that they like
Output: A set (no repeats) of brand recommendations based on
      similar users preferences

1. When a user's brands are given to us, we will calculate the input user's
jaccard similarity with every person in our brandsfor dictionary

2. We will pick the K most similar users and recommend
the brands that they like that the given user doesn't know about

EXAMPLE:
Given User likes ['Target', 'Old Navy', 'Banana Republic', 'H&M']
Outputs: ['Forever 21', 'Gap', 'Steve Madden']
'''

given_user = ['Target', 'Old Navy', 'Banana Republic', 'H&M']

similarities = {key: jaccard(brandsfor[key], given_user) for key in brandsfor}

for user, brand_list in brandsfor.iteritems():
    print user, brand_list
    similarities[user] = jaccard(brand_list, given_user)

    similarities

K = 5 #number of similar users to look at


# Now for the top K most similar users, let's aggregate the brands they like.
# I sort by the jaccard similarty so most similar users are first
# I use the sorted method, but because I'm dorting dictionaries
# I specify the "key" as the value of the dictionary
# the key is what the list should sort on
# so the most similar users end up being on top
most_similar_users = sorted(similarities, key=similarities.get, reverse=True)[:K]

# list of K similar users' IDs
most_similar_users

# let's see what some of the most similar users likes
brandsfor[most_similar_users[0]]

brandsfor[most_similar_users[3]]

brands_to_recommend = set()
for user in most_similar_users:
    # for each user
    brands_to_recommend.update(set(brandsfor[user]))
    # add to the set of brands_to_recommend

brands_to_recommend
# UH OH WE HAVE DUPLICATES. Banana Republic, Old Navy, Target are all repeats.

# EXERCISE: use a set difference so brands_to_recommend only has
# brands that given_user hasn't seen yet

# ANSWER HERE
brands_to_recommend = brands_to_recommend - set(given_user)

# without duplicates
brands_to_recommend

####################
##One Step Further##
####################

# We can take this one step further and caculate a "score" of recommendation
# We will define the score as being the number of times
# a brand appears within the first K users
brands_to_recommend = []
for user in most_similar_users:
    brands_to_recommend += list(set(brandsfor[user]) - set(given_user))

# Use a counter to count the number of times a brand appears
recommend_with_scores = Counter(brands_to_recommend)

# Now we see Gap has the highest score!
recommend_with_scores

###################
#### Item based ###
###################

'''
We can also define a similary between items using jaccard similarity.
We can say that the similarity between two items is the jaccard similarity
between the sets of people who like the two brands.

Example: similarity of Gap to Target is:
'''
# filter users by liking Gap
gap_lovers = set(user_brands['Gap' == user_brands.Store].ID)
old_navy_lovers = set(user_brands['Old Navy' == user_brands.Store].ID)

# similarty between Gap and Old Navy
jaccard(gap_lovers, old_navy_lovers)


guess_lovers = set(user_brands['Guess' == user_brands.Store].ID)
# similarty between Gap andGuess
jaccard(guess_lovers, gap_lovers)


calvin_lovers = set(user_brands['Calvin Klein' == user_brands.Store].ID)
# similarty between Gap and Calvin Klein
jaccard(calvin_lovers, gap_lovers)

```
